import axios from 'axios';
import type { User, CosplayProfile, Vote, Scores } from '../types';

// Configura√ß√£o base da API - usa a mesma origem do frontend
const API_BASE_URL = `${window.location.origin}/api`;

// Criar inst√¢ncia do axios com configura√ß√µes padr√£o
const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor para adicionar token automaticamente
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Interceptor para tratar respostas e erros
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Token expirado ou inv√°lido - limpar dados e redirecionar
      localStorage.removeItem('authToken');
      localStorage.removeItem('currentUser');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// ===============================
// SERVI√áOS DE AUTENTICA√á√ÉO
// ===============================

export const authService = {
  async login(email: string, password: string, role: 'admin' | 'juror') {
    try {
      const response = await api.post('/auth/login', {
        email,
        password,
        role
      });

      const { user, token } = response.data;
      
      // Salvar token e dados do usu√°rio
      localStorage.setItem('authToken', token);
      localStorage.setItem('currentUser', JSON.stringify(user));
      
      return { user, token };
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro no login');
    }
  },

  async register(userData: {
    name: string;
    email: string;
    password: string;
    role: 'admin' | 'juror';
  }) {
    try {
      const response = await api.post('/auth/register', userData);
      return response.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro no registro');
    }
  },

  async getCurrentUser() {
    try {
      const response = await api.get('/auth/me');
      return response.data.user;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao obter usu√°rio');
    }
  },

  logout() {
    localStorage.removeItem('authToken');
    localStorage.removeItem('currentUser');
  },

  getStoredUser(): User | null {
    const userData = localStorage.getItem('currentUser');
    return userData ? JSON.parse(userData) : null;
  },

  getStoredToken(): string | null {
    return localStorage.getItem('authToken');
  }
};

// ===============================
// SERVI√áOS DE PERFIS
// ===============================

export const profileService = {
  async getAllProfiles(): Promise<CosplayProfile[]> {
    try {
      const response = await api.get('/profiles');
      return response.data.profiles.map((profile: any) => ({
        id: profile.id.toString(),
        name: profile.name,
        character: profile.character,
        anime: profile.anime,
        image_urls: profile.image_urls || [],
        description: profile.description || '',
        isVisible: false, // Ser√° definido pelo contexto
        voting_status: profile.voting_status,
        final_score: profile.final_score ? parseFloat(profile.final_score) : undefined,
        total_final_votes: profile.total_final_votes ? parseInt(profile.total_final_votes) : undefined,
        modality: profile.modality || 'desfile',
      }));
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar perfis');
    }
  },

  async getAllPublicProfiles(): Promise<CosplayProfile[]> {
    try {
      // Este endpoint n√£o requer autentica√ß√£o
      const response = await api.get('/profiles/public');
      console.log('üîç DEBUG api.ts - Perfis recebidos do backend:', response.data.profiles);
      return response.data.profiles.map((profile: any) => {
        console.log(`üîç DEBUG api.ts - Mapeando perfil ${profile.name}:`, {
          id: profile.id,
          modality_backend: profile.modality,
          modality_final: profile.modality || 'desfile'
        });
        return {
          id: profile.id.toString(),
          name: profile.name,
          character: profile.character,
          anime: profile.anime,
          image_urls: profile.image_urls || [],
          description: profile.description || '',
          isVisible: false, // Ser√° definido pelo contexto
          voting_status: profile.voting_status,
          final_score: profile.final_score ? parseFloat(profile.final_score) : undefined,
          total_final_votes: profile.total_final_votes ? parseInt(profile.total_final_votes) : undefined,
          modality: profile.modality || 'desfile',
        };
      });
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar perfis p√∫blicos');
    }
  },

  async getProfile(id: string): Promise<CosplayProfile> {
    try {
      const response = await api.get(`/profiles/${id}`);
      const profile = response.data.profile;
      return {
        id: profile.id.toString(),
        name: profile.name,
        character: profile.character,
        anime: profile.anime,
        image_urls: profile.image_urls || [],
        description: profile.description || '',
        isVisible: false, // Ser√° definido pelo contexto
        voting_status: profile.voting_status,
        final_score: profile.final_score ? parseFloat(profile.final_score) : undefined,
        total_final_votes: profile.total_final_votes ? parseInt(profile.total_final_votes) : undefined,
        modality: profile.modality || 'desfile',
      };
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar perfil');
    }
  },

  async createProfile(profileData: {
    name: string;
    character: string;
    anime: string;
    image_urls: string[];
    description: string;
    modality?: 'desfile' | 'presentation';
  }): Promise<CosplayProfile> {
    try {
      const response = await api.post('/profiles', profileData);
      const profile = response.data.profile;
      return {
        id: profile.id.toString(),
        name: profile.name,
        character: profile.character,
        anime: profile.anime,
        image_urls: profile.image_urls || [],
        description: profile.description || '',
        isVisible: false,
        voting_status: 'pending',
        final_score: undefined,
        total_final_votes: undefined,
        modality: profile.modality || 'desfile',
      };
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao criar perfil');
    }
  },

  async updateProfile(id: string, profileData: Partial<{
    name: string;
    character: string;
    anime: string;
    image_urls: string[];
    description: string;
    modality: 'desfile' | 'presentation';
  }>): Promise<CosplayProfile> {
    try {
      const response = await api.put(`/profiles/${id}`, profileData);
      const profile = response.data.profile;
      return {
        id: profile.id.toString(),
        name: profile.name,
        character: profile.character,
        anime: profile.anime,
        image_urls: profile.image_urls || [],
        description: profile.description || '',
        isVisible: false,
        voting_status: profile.voting_status,
        final_score: profile.final_score ? parseFloat(profile.final_score) : undefined,
        total_final_votes: profile.total_final_votes ? parseInt(profile.total_final_votes) : undefined,
        modality: profile.modality || 'desfile',
      };
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao atualizar perfil');
    }
  },

  async deleteProfile(id: string): Promise<void> {
    try {
      await api.delete(`/profiles/${id}`);
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao excluir perfil');
    }
  },

  async getProfileResults(id: string) {
    try {
      const response = await api.get(`/profiles/${id}/results`);
      return response.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar resultados');
    }
  },

  async finalizeProfileScore(profileId: string, finalScore: number, totalVotes: number): Promise<void> {
    try {
      await api.put(`/profiles/${profileId}/finalize`, {
        final_score: finalScore,
        total_final_votes: totalVotes,
        voting_status: 'completed'
      });
      console.log('üíæ Score final salvo na database:', { profileId, finalScore, totalVotes });
    } catch (error: any) {
      console.error('‚ùå Erro ao salvar na database, usando fallback local');
      throw new Error(error.response?.data?.error || 'Erro ao finalizar perfil na database');
    }
  },

  async getRanking(): Promise<CosplayProfile[]> {
    try {
      console.log('üîÑ Chamando API /profiles/ranking...');
      const response = await api.get('/profiles/ranking');
      console.log('üì¶ Resposta da API ranking:', response.data);
      
      // Se n√£o h√° perfis no ranking, retornar array vazia sem erro
      if (!response.data.ranking || response.data.ranking.length === 0) {
        console.log('‚ö†Ô∏è Nenhum perfil no ranking retornado pela API');
        return [];
      }
      
      const mappedRanking = response.data.ranking.map((profile: any) => ({
        id: profile.id.toString(),
        name: profile.name,
        character: profile.character,
        anime: profile.anime,
        image_urls: profile.image_urls || [],
        description: profile.description || '',
        modality: profile.modality || 'desfile',
        isVisible: false,
        voting_status: profile.voting_status,
        final_score: profile.final_score ? parseFloat(profile.final_score) : undefined,
        total_final_votes: profile.total_final_votes ? parseInt(profile.total_final_votes) : undefined,
      }));
      
      console.log('üèÜ Ranking mapeado:', mappedRanking);
      return mappedRanking;
    } catch (error: any) {
      console.error('‚ùå Erro ao obter ranking:', error.response?.data?.error || error.message);
      // Retornar array vazia em caso de erro, para n√£o quebrar a UI
      return [];
    }
  },

  async clearRanking(): Promise<void> {
    try {
      console.log('üóëÔ∏è Limpando dados do ranking...');
      await api.delete('/profiles/ranking/clear');
      console.log('‚úÖ Ranking limpo com sucesso!');
    } catch (error: any) {
      console.error('‚ùå Erro ao limpar ranking:', error.response?.data?.error || error.message);
      throw new Error(error.response?.data?.error || 'Erro ao limpar ranking');
    }
  }
};

// ===============================
// SERVI√áOS DE VOTA√á√ÉO
// ===============================

export const voteService = {
  async getMyVotes(): Promise<Vote[]> {
    try {
      const response = await api.get('/votes/my');
      return response.data.votes.map((vote: any) => ({
        jurorId: vote.juror_id.toString(),
        cosplayId: vote.cosplay_id.toString(),
        scores: {
          indumentaria: vote.indumentaria,
          similaridade: vote.similaridade,
          qualidade: vote.qualidade,
        },
        submitted: vote.submitted
      }));
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar votos');
    }
  },

  async submitVote(cosplayId: string, scores: Scores, submitted: boolean = true): Promise<Vote> {
    try {
      const voteData: any = {
        cosplay_id: parseInt(cosplayId),
        indumentaria: scores.indumentaria,
        similaridade: scores.similaridade,
        qualidade: scores.qualidade,
        submitted
      };

      // Incluir interpretacao e performance se existirem (modalidade apresenta√ß√£o)
      const presentationScores = scores as any;
      if (presentationScores.interpretacao !== undefined && presentationScores.interpretacao > 0) {
        voteData.interpretacao = presentationScores.interpretacao;
      }
      if (presentationScores.performance !== undefined && presentationScores.performance > 0) {
        voteData.performance = presentationScores.performance;
      }

      const response = await api.post('/votes', voteData);
      
      const vote = response.data.vote;
      return {
        jurorId: vote.juror_id.toString(),
        cosplayId: vote.cosplay_id.toString(),
        scores: {
          indumentaria: vote.indumentaria,
          similaridade: vote.similaridade,
          qualidade: vote.qualidade,
          interpretacao: vote.interpretacao,
          performance: vote.performance
        },
        submitted: vote.submitted
      };
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao enviar voto');
    }
  },

  async checkVote(cosplayId: string) {
    try {
      const response = await api.get(`/votes/check/${cosplayId}`);
      return response.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao verificar voto');
    }
  },

  async deleteVote(cosplayId: string): Promise<void> {
    try {
      await api.delete(`/votes/${cosplayId}`);
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao excluir voto');
    }
  },

  async getStatistics() {
    try {
      const response = await api.get('/votes/statistics');
      return response.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar estat√≠sticas');
    }
  },

  async getAllVotes(): Promise<Vote[]> {
    try {
      const response = await api.get('/votes/all');
      return response.data.votes.map((vote: any) => ({
        jurorId: vote.juror_id.toString(),
        cosplayId: vote.cosplay_id.toString(),
        scores: {
          indumentaria: vote.indumentaria,
          similaridade: vote.similaridade,
          qualidade: vote.qualidade,
        },
        submitted: vote.submitted
      }));
    } catch (error: any) {
      // Se n√£o existir endpoint, tentar usar estat√≠sticas
      console.log('‚ö†Ô∏è Endpoint /votes/all n√£o existe, usando votos do contexto');
      throw new Error(error.response?.data?.error || 'Erro ao buscar todos os votos');
    }
  }
};

// ===============================
// SERVI√áOS DE CONTROLE DE VOTA√á√ÉO
// ===============================

export const votingService = {
  async getCurrentVisibleProfile(): Promise<CosplayProfile | null> {
    try {
      const response = await api.get('/voting/current');
      const profile = response.data.current_profile;
      
      if (!profile) return null;
      
      return {
        id: profile.id.toString(),
        name: profile.name,
        character: profile.character,
        anime: profile.anime,
        image_urls: profile.image_urls || [],
        description: profile.description || '',
        isVisible: true,
        voting_status: profile.voting_status || 'active',
        final_score: profile.final_score ? parseFloat(profile.final_score) : undefined,
        total_final_votes: profile.total_final_votes ? parseInt(profile.total_final_votes) : undefined,
        modality: profile.modality || 'desfile',
      };
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar perfil atual');
    }
  },

  async setVisibleProfile(profileId: string): Promise<void> {
    try {
      await api.put(`/voting/set-visible/${profileId}`);
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao definir perfil vis√≠vel');
    }
  },

  async hideCurrentProfile(): Promise<void> {
    try {
      await api.put('/voting/set-visible/null');
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao ocultar perfil');
    }
  },

  async getVotingStatus() {
    try {
      const response = await api.get('/voting/status');
      return response.data;
    } catch (error: any) {
      // Se for erro de acesso negado, propagar a mensagem espec√≠fica
      if (error.response?.status === 403 || error.response?.data?.error?.includes('Acesso negado')) {
        throw new Error(error.response.data.error || 'Acesso negado. Requer papel: admin');
      }
      throw new Error(error.response?.data?.error || 'Erro ao buscar status');
    }
  },

  async getVotingStatistics(): Promise<any> {
    try {
      const response = await api.get('/voting/status');
      return response.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar estat√≠sticas');
    }
  },

  async pingPresence(): Promise<void> {
    try {
      await api.post('/presence/ping');
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao buscar estat√≠sticas');
    }
  },

  async finalizeCurrentProfile(): Promise<void> {
    try {
      // Por enquanto, vamos simular a finaliza√ß√£o apenas obtendo o status atual
      // Isso for√ßa uma verifica√ß√£o do estado atual no backend
      await api.get('/voting/status');
      console.log('üìä Status verificado - perfil anterior processado pelo backend');
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao verificar status do perfil atual');
    }
  },

  async finalizeProfile(profileId: string): Promise<void> {
    try {
      // Tentar usar endpoint espec√≠fico se existir, caso contr√°rio usar o gen√©rico
      await api.put(`/profiles/${profileId}/finalize`);
    } catch (error: any) {
      // Se n√£o existir endpoint espec√≠fico, simula a finaliza√ß√£o
      console.log('üìä Finalizando perfil via status check');
      throw new Error(error.response?.data?.error || 'Erro ao finalizar perfil');
    }
  },

  async setVotingMode(mode: 'desfile' | 'presentation'): Promise<void> {
    try {
      await api.put('/voting/set-mode', { mode });
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao alterar modalidade');
    }
  },

  async getVotingMode(): Promise<'desfile' | 'presentation'> {
    try {
      const response = await api.get('/voting/mode');
      return response.data.mode;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Erro ao obter modalidade');
    }
  }
};

export default api;